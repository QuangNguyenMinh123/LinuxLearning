#include <linux/module.h>
#include <linux/init.h>
#include <linux/gpio.h>
#include <linux/spi/spi.h>
#include <linux/delay.h>
#include <linux/proc_fs.h>
#include <linux/uaccess.h>
#include <linux/pinctrl/consumer.h>
/*******************************************************************************/
/* Meta Information */
MODULE_LICENSE("GPL");
MODULE_AUTHOR("QuangNM13");
MODULE_DESCRIPTION("A SPI driver for ILI9341 LCD");
/*******************************************************************************/
#define LOW					0
#define HIGH				1
#define COMPATIBLE			"QuangNM13,ILI9341"
#define FONT_SIZE			6
#define MAX_COL				320
#define MAX_ROW				240
/*******************************************************************************/

/*******************************************************************************/
typedef struct position {
	unsigned char x;
	unsigned char y;
} Position_t;
#define MAJIC_NO				100
#define IOCTL_GOTOXY			_IOW(MAJIC_NO, 3, Position_t)
#define IOCTL_CLEAR				_IO(MAJIC_NO, 4)
/*******************************************************************************/
typedef struct ILI9341Type{
	struct spi_device *ili9341;
	int col;
	int row;
}ILI9341Type;

ILI9341Type ili9341 =
{
	NULL,
	0,
	0
};
/*******************************************************************************/
const uint8_t LCD_Font5x7[][FONT_SIZE] = {
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	// 0
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	// 1
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	// 2
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	// 3
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	// 4
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	// 5
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	// 6
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	// 7
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	// \8
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	// 9
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	// \n
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	// 11
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	// 12
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	// 13
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	// 14
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	// 15
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	// 16
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	// 17
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	// 18
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	// 19
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	// 20
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	// 21
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	// 22
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	// 23
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	// 24
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	// 25
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	// 26
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	// 27
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	// 28
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	// 29
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	// 30
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	// 31
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // sp
	{ 0x00, 0x00, 0x2f, 0x00, 0x00, 0x00 },   // !
	{ 0x00, 0x07, 0x00, 0x07, 0x00, 0x00 },   // "
	{ 0x14, 0x7f, 0x14, 0x7f, 0x14, 0x00 },   // #
	{ 0x24, 0x2a, 0x7f, 0x2a, 0x12, 0x00 },   // $
	{ 0x32, 0x34, 0x08, 0x16, 0x26, 0x00 },   // %
	{ 0x36, 0x49, 0x55, 0x22, 0x50, 0x00 },   // &
	{ 0x00, 0x05, 0x03, 0x00, 0x00, 0x00 },   // '
	{ 0x00, 0x1c, 0x22, 0x41, 0x00, 0x00 },   // (
	{ 0x00, 0x41, 0x22, 0x1c, 0x00, 0x00 },   // )
	{ 0x14, 0x08, 0x3E, 0x08, 0x14, 0x00 },   // *
	{ 0x08, 0x08, 0x3E, 0x08, 0x08, 0x00 },   // +
	{ 0x00, 0x00, 0x50, 0x30, 0x00, 0x00 },   // ,
	{ 0x10, 0x10, 0x10, 0x10, 0x10, 0x00 },   // -
	{ 0x00, 0x60, 0x60, 0x00, 0x00, 0x00 },   // .
	{ 0x20, 0x10, 0x08, 0x04, 0x02, 0x00 },   // /
	{ 0x3E, 0x51, 0x49, 0x45, 0x3E, 0x00 },   // 0
	{ 0x00, 0x42, 0x7F, 0x40, 0x00, 0x00 },   // 1
	{ 0x42, 0x61, 0x51, 0x49, 0x46, 0x00 },   // 2
	{ 0x21, 0x41, 0x45, 0x4B, 0x31, 0x00 },   // 3
	{ 0x18, 0x14, 0x12, 0x7F, 0x10, 0x00 },   // 4
	{ 0x27, 0x45, 0x45, 0x45, 0x39, 0x00 },   // 5
	{ 0x3C, 0x4A, 0x49, 0x49, 0x30, 0x00 },   // 6
	{ 0x01, 0x71, 0x09, 0x05, 0x03, 0x00 },   // 7
	{ 0x36, 0x49, 0x49, 0x49, 0x36, 0x00 },   // 8
	{ 0x06, 0x49, 0x49, 0x29, 0x1E, 0x00 },   // 9
	{ 0x00, 0x36, 0x36, 0x00, 0x00, 0x00 },   // :
	{ 0x00, 0x56, 0x36, 0x00, 0x00, 0x00 },   // ;
	{ 0x08, 0x14, 0x22, 0x41, 0x00, 0x00 },   // <
	{ 0x14, 0x14, 0x14, 0x14, 0x14, 0x00 },   // =
	{ 0x00, 0x41, 0x22, 0x14, 0x08, 0x00 },   // >
	{ 0x02, 0x01, 0x51, 0x09, 0x06, 0x00 },   // ?
	{ 0x32, 0x49, 0x59, 0x51, 0x3E, 0x00 },   // @
	{ 0x7E, 0x11, 0x11, 0x11, 0x7E, 0x00 },   // A
	{ 0x7F, 0x49, 0x49, 0x49, 0x36, 0x00 },   // B
	{ 0x3E, 0x41, 0x41, 0x41, 0x22, 0x00 },   // C
	{ 0x7F, 0x41, 0x41, 0x22, 0x1C, 0x00 },   // D
	{ 0x7F, 0x49, 0x49, 0x49, 0x41, 0x00 },   // E
	{ 0x7F, 0x09, 0x09, 0x09, 0x01, 0x00 },   // F
	{ 0x3E, 0x41, 0x49, 0x49, 0x7A, 0x00 },   // G
	{ 0x7F, 0x08, 0x08, 0x08, 0x7F, 0x00 },   // H
	{ 0x00, 0x41, 0x7F, 0x41, 0x00, 0x00 },   // I
	{ 0x20, 0x40, 0x41, 0x3F, 0x01, 0x00 },   // J
	{ 0x7F, 0x08, 0x14, 0x22, 0x41, 0x00 },   // K
	{ 0x7F, 0x40, 0x40, 0x40, 0x40, 0x00 },   // L
	{ 0x7F, 0x02, 0x0C, 0x02, 0x7F, 0x00 },   // M
	{ 0x7F, 0x04, 0x08, 0x10, 0x7F, 0x00 },   // N
	{ 0x3E, 0x41, 0x41, 0x41, 0x3E, 0x00 },   // O
	{ 0x7F, 0x09, 0x09, 0x09, 0x06, 0x00 },   // P
	{ 0x3E, 0x41, 0x51, 0x21, 0x5E, 0x00 },   // Q
	{ 0x7F, 0x09, 0x19, 0x29, 0x46, 0x00 },   // R
	{ 0x46, 0x49, 0x49, 0x49, 0x31, 0x00 },   // S
	{ 0x01, 0x01, 0x7F, 0x01, 0x01, 0x00 },   // T
	{ 0x3F, 0x40, 0x40, 0x40, 0x3F, 0x00 },   // U
	{ 0x1F, 0x20, 0x40, 0x20, 0x1F, 0x00 },   // V
	{ 0x3F, 0x40, 0x38, 0x40, 0x3F, 0x00 },   // W
	{ 0x63, 0x14, 0x08, 0x14, 0x63, 0x00 },   // X
	{ 0x07, 0x08, 0x70, 0x08, 0x07, 0x00 },   // Y
	{ 0x61, 0x51, 0x49, 0x45, 0x43, 0x00 },   // Z
	{ 0x00, 0x7F, 0x41, 0x41, 0x00, 0x00 },   // [
	{ 0x55, 0x2A, 0x55, 0x2A, 0x55, 0x00 },   // 55
	{ 0x00, 0x41, 0x41, 0x7F, 0x00, 0x00 },   // ]
	{ 0x04, 0x02, 0x01, 0x02, 0x04, 0x00 },   // ^
	{ 0x40, 0x40, 0x40, 0x40, 0x40, 0x00 },   // _
	{ 0x00, 0x01, 0x02, 0x04, 0x00, 0x00 },   // '
	{ 0x20, 0x54, 0x54, 0x54, 0x78, 0x00 },   // a
	{ 0x7F, 0x48, 0x44, 0x44, 0x38, 0x00 },   // b
	{ 0x38, 0x44, 0x44, 0x44, 0x20, 0x00 },   // c
	{ 0x38, 0x44, 0x44, 0x48, 0x7F, 0x00 },   // d
	{ 0x38, 0x54, 0x54, 0x54, 0x18, 0x00 },   // e
	{ 0x08, 0x7E, 0x09, 0x01, 0x02, 0x00 },   // f
	{ 0x0C, 0x52, 0x52, 0x52, 0x3E, 0x00 },   // g
	{ 0x7F, 0x08, 0x04, 0x04, 0x78, 0x00 },   // h
	{ 0x00, 0x44, 0x7D, 0x40, 0x00, 0x00 },   // i
	{ 0x20, 0x40, 0x44, 0x3D, 0x00, 0x00 },   // j
	{ 0x7F, 0x10, 0x28, 0x44, 0x00, 0x00 },   // k
	{ 0x00, 0x41, 0x7F, 0x40, 0x00, 0x00 },   // l
	{ 0x7C, 0x04, 0x18, 0x04, 0x78, 0x00 },   // m
	{ 0x7C, 0x08, 0x04, 0x04, 0x78, 0x00 },   // n
	{ 0x38, 0x44, 0x44, 0x44, 0x38, 0x00 },   // o
	{ 0x7C, 0x14, 0x14, 0x14, 0x08, 0x00 },   // p
	{ 0x08, 0x14, 0x14, 0x18, 0x7C, 0x00 },   // q
	{ 0x7C, 0x08, 0x04, 0x04, 0x08, 0x00 },   // r
	{ 0x48, 0x54, 0x54, 0x54, 0x20, 0x00 },   // s
	{ 0x04, 0x3F, 0x44, 0x40, 0x20, 0x00 },   // t
	{ 0x3C, 0x40, 0x40, 0x20, 0x7C, 0x00 },   // u
	{ 0x1C, 0x20, 0x40, 0x20, 0x1C, 0x00 },   // v
	{ 0x3C, 0x40, 0x30, 0x40, 0x3C, 0x00 },   // w
	{ 0x44, 0x28, 0x10, 0x28, 0x44, 0x00 },   // x
	{ 0x0C, 0x50, 0x50, 0x50, 0x3C, 0x00 },   // y
	{ 0x44, 0x64, 0x54, 0x4C, 0x44, 0x00 },   // z
};
/*******************************************************************************/
static struct gpio_desc *resetPin = NULL;
static struct gpio_desc *dcPin = NULL; 
/*******************************************************************************/
static int ILI9341_probe(struct spi_device *pdev);
static int ILI9341_remove(struct spi_device *pdev);
static long int ILI9341_Ioctl(struct file *file, unsigned cmd, unsigned long arg);
static ssize_t ILI9341_ProcWrite(struct file *File, const char *user_buffer, size_t count, loff_t *offs);
/*******************************************************************************/
static void ILI9341_Write(ILI9341Type *device, bool isCommand, char* buff, int size)
{
	if (isCommand)						/* If command is sent */
		gpiod_set_value(dcPin, LOW);
	else								/* If data is sent */
	{
		gpiod_set_value(dcPin, HIGH);
	}
	spi_write(device->ili9341, buff, size);
	gpiod_set_value(dcPin, LOW);
}

static void ILI9341_Reset(void)
{
	gpiod_set_value(resetPin, LOW);
	mdelay(100);
	gpiod_set_value(resetPin, HIGH);
}

static void ILI9341_goto(ILI9341Type *device, int x, int y)
{
	int xVal = (x <= MAX_ROW) ? (x) : (MAX_ROW);
	int yVal = (y <= MAX_COL) ? (y) : (MAX_COL);
	char buff[3] = {
		0
	};
	ILI9341_Write(device, true, buff, sizeof(buff));
	device->col = xVal;
	device->row = yVal;
}

static void ILI9341_Nextline(ILI9341Type *device)
{
	if (device->row + 1 <= MAX_ROW)
		ILI9341_goto(device, 0, device->row + 1);
	else
		ILI9341_goto(device, 0, 0);
}

static void ILI9341_printChar(ILI9341Type *device, char ch)
{
	if (ch == '\n')
		ILI9341_Nextline(device);
	else
	{
		if (ili9341.col + FONT_SIZE < MAX_COL)
		{
			ili9341.col += FONT_SIZE;
		}
		else
		{
			if (ili9341.row + 1 > MAX_ROW)
			{
				ILI9341_goto(device, 0, 0);
			}
			else
			{
				ILI9341_goto(device, 0, device->row + 1);
			}
		}
		ILI9341_Write(device, false, LCD_Font5x7[ch], FONT_SIZE);
	}

}

static void ILI9341_print(ILI9341Type *device, char* ch)
{
	while (*ch != 0)
	{
		ILI9341_printChar(device, *ch);
		ch++;
	}
}

static void ILI9341_printImage(ILI9341Type *device, char* ch, int size)
{
	ILI9341_goto(device, 0, 0);
	ILI9341_Write(device, false, ch, size);
}

static void ILI9341_ClearScreen(ILI9341Type *device)
{
	char buff[504] = {0};
	ILI9341_goto(device, 0, 0);
	ILI9341_Write(device, false, buff, 504);
}

static void ILI9341_Init(ILI9341Type *device)
{
	char buff[] = {
		0x21,		/* Function set */
		0xC0,
		0x20,		/* Basic command */
	};
	ILI9341_Reset();
	ILI9341_Write(device, true, buff, sizeof(buff));
}
/*******************************************************************************/
static struct of_device_id ili9341_id[] = {
	{
		.compatible = COMPATIBLE,
	},
	{}
};
MODULE_DEVICE_TABLE(spi0, ili9341_id);
static struct spi_driver ili9341_driver = {
	.probe = ILI9341_probe,
	.remove = ILI9341_remove,
	.driver = {
		.name = "ILI9341_Driver",
		.of_match_table = ili9341_id,
	}
};
module_spi_driver(ili9341_driver);
static struct file_operations fops = {
	.owner = THIS_MODULE,
	.open = NULL,
	.release = NULL,
	.unlocked_ioctl = ILI9341_Ioctl,
	.write = ILI9341_ProcWrite,
};
static struct proc_dir_entry *proc_file;
/*******************************************************************************/
static long int ILI9341_Ioctl(struct file *file, unsigned cmd, unsigned long arg)
{
	Position_t *pos = NULL;
	void __user *argp = (void __user *)arg;
	printk("ILI9341_Ioctl: \n");
	if (cmd == IOCTL_GOTOXY)
	{
		pos = kmalloc(sizeof(Position_t), GFP_KERNEL);
		copy_from_user(pos, argp, sizeof(Position_t));
		printk("x = %d, y = %d\n",(int)pos->x, (int)pos->y);
		ILI9341_goto(&ili9341, pos->x, pos->y);
	}
	else if (cmd == IOCTL_CLEAR)
	{
		ILI9341_ClearScreen(&ili9341);
	}
	
	return 0;
}

static ssize_t ILI9341_ProcWrite(struct file *File, const char *user_buffer, size_t count, loff_t *offs) {
	u8 buffer[100];
	int cnt;
	memset(buffer, 0 , sizeof(buffer));
	printk("ILI9341_ProcWrite: \n");
	cnt = copy_from_user(buffer, user_buffer, count - 1);
	ILI9341_print(&ili9341, buffer);
	return count;
}

static int ILI9341_probe(struct spi_device *pdev)
{
	struct device *dev = &pdev->dev;
	printk("ILI9341_probe\n");
	/* Check device properties */
	if (!device_property_present(dev, "commandData-gpio"))
	{
		printk("dt_probe - Error! Device property 'commandData-gpio' not found\n");
	}
	if (!device_property_present(dev, "reset-gpio"))
	{
		printk("dt_probe - Error! Device property 'reset-gpio' not found\n");
	}
	/* Obtain GPIO */
	resetPin = gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
	if (IS_ERR(resetPin))
	{
		printk("ILI9341_probe - Error! cannot setup the reset-gpio\n");
		gpiod_put(resetPin);
	}
	gpiod_set_value(resetPin, HIGH);
	dcPin = gpiod_get(dev, "commandData", GPIOD_OUT_HIGH);
	if (IS_ERR(dcPin))
	{
		printk("ILI9341_probe - Error! cannot setup the dcPin\n");
		gpiod_put(dcPin);
	}
	gpiod_set_value(dcPin, HIGH);
	/* Obtain SPI device */
	ili9341.ili9341 = pdev;
	/* Initialize device */
	ILI9341_Init(&ili9341);
	ILI9341_ClearScreen(&ili9341);
	ILI9341_goto(&ili9341, 0, 0);
	/* Create proc */
	proc_file = proc_create("ili9341", 0666, NULL, &fops);
	if(proc_file == NULL) {
		printk("SSD1306_probe: Error creating /proc/ili9341\n");
		return -ENOMEM;
	}
	return 0;
}
/**
 * @brief This function is called, when the module is removed
 */
static int ILI9341_remove(struct spi_device *pdev)
{
	struct pinctrl* checkPinCtrl;
	printk("ILI9341_remove\n");
	gpiod_put(resetPin);
	gpiod_put(dcPin);
	proc_remove(proc_file);
	checkPinCtrl = devm_pinctrl_get_select(&pdev->dev, "spi0_pinmux_default");
	if (IS_ERR(checkPinCtrl))
	{
		printk("ILI9341_remove: - Error! cannot reset spi0 pinmux to default\n");
	}
	return 0;
}
/*******************************************************************************/